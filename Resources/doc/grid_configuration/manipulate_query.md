Manipulating the query builder
============================

The Entity Source provides two ways of manipulating the query which is used for generating the grid - 

1. (Recommended) Using a callback method to modify the query that was generated by the grid
2. (Advanced) Injecting a custom QueryBuilder object which then will be expanded by the grid

## 1. Using a callback
This is the recommended way of modifying the query because the query is still created by the grid and therefore we can ensure its integrity. 
This method should be sufficient for virtual every use-case.

```php
<?php
...
$source->manipulateQuery($callback);

$grid->setSource($source);
...
```

### Method Source::manipulateQuery parameters

|parameter|Type|Default value|Description|
|:--:|:--|:--|:--|:--|
|callback|[\Closure](http://php.net/manual/en/functions.anonymous.php) or [callable](http://php.net/manual/en/language.types.callable.php)|null|Callback to manipulate the query. Null means no callback.|

### Callback parameters

|parameter|Type|Description|
|:--:|:--|:--|:--|:--|
|query|instance of QueryBuilder|The QueryBuilder instance before its execution|

### Examples

```php
<?php
...
$source->manipulateQuery(
    function ($query)
    {
        $query->resetDQLPart('orderBy');
    }
);

$grid->setSource($source);
...
```

If you want to pass some context parameters:

```php
<?php
...
$tableAlias = $source::TABLE_ALIAS;

$source->manipulateQuery(
    function ($query) use ($tableAlias)
    {
        $query->andWhere($tableAlias . '.active = 1');
    }
);

$grid->setSource($source);
...
```

**Warning**: You must use "andWhere" instead of "Where" statement otherwise column filtering won't work. Same thing about the order and the group (addOrder, addGroup).




## 2. Injecting a custom QueryBuilder
In rare situations, adjusting the query with a callback is not possible because you do not have the full knowledge of how the query should be changed (e.g. the business logic for creating the query sits in an external serice/repository). 
For this situations, it is possible to first the querybuilder from the remote service, and then inject it into grid so that the grid can expand on it.

```php
<?php
...
$businessQueryBuilder = $myOpaqueRepository->_createDefaultFilteredQueryBuilder();
$source->setStartingQueryBuilder($businessQueryBuilder);

$grid->setSource($source);
...
```

### Method Source::setStartingQueryBuilder parameters

|parameter|Type|Description|
|:--:|:--|:--|:--|:--|
|queryBuilder|Doctrine\ORM\QueryBuilder|(mandatory) The default QueryBuilder which should be expanded|

**Warning**: Please make sure you absolutely cannot use the callback to accomplish your goals before injecting the QueryBuilder. The callback is a cleaner and safer way of accomplishing the same task in 90% of the times.
Injecting the QueryBuilder comes with the following risks -
* OrderBy settings in the original query builder will be overridden by the grid to do its sorting
* Injecting a complex QueryBuilder can lead to clash of query namespaces/aliases between the original QB and what was added by the grid

If you are injecting your own QueryBuilder and having problems with the grid, please try removing the injection or using the callback method first as odds are your problem is caused by a complex query which could not be guessed accurately by the grid.
